name: "PR Comment on Release"
description: "Comments on a (merged) PR when it is included in a GitHub release."
author: hello@cloudposse.com
branding:
  icon: "file"
  color: "white"
inputs:
  retries:
    required: false
    description: "Number of retries"
    default: "3"
  include_regex:
    required: false
    description: "JavaScript regex used to filter releases."
    default: "/.*/g"
  release_id:
    required: false
    description: "The ID of the release. Defaults to `github.event.release.id`."
    default: ""
runs:
  using: "composite"
  steps:
    - uses: actions/github-script@v7
      with:
        result-encoding: string
        retries: ${{ inputs.retries }}
        env:
          INPUT_RELEASE_ID: ${{ inputs.release_id }}
        script: |
          const { INPUT_RELEASE_ID } = process.env

          switch(context.eventName) {
            case ('release'):
              break;
            case ('workflow_run'):
              core.warning("This action is designed to run on 'release', not 'workflow_run'. Even when corresponding to a workflow triggered by 'release', 'workflow_run' may not work due to its event context schema.");
              break;
            case ('pull_request' && RELEASE_ID):
              core.error("This action is meant to only run on 'release'. 'pull_request' is reserved for testing, and 'release_id' was not supplied.");
              break;
            case ('pull_request'):
              core.warning("This action is meant to only run on 'release'. 'pull_request' is reserved for testing.");
              break;
            default:
              core.error(`The ${context.eventName} event is not supported by this action.`);
          }

          // Function to check if a value is unique in an array
          function onlyUnique(value, index, array) {
            return array.indexOf(value) === index;
          }

          // Function to create or update a comment for a pull request (PR) associated with a release
          async function createCommentForPR(pr_id, release) {
            // Parameters for fetching comments related to the PR
            const parameters = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_id,
              per_page: 100,
            }
            
            // Constructing the message to be posted or updated as a comment
            const messageId = `<!-- release-pr-comment:${release.id} -->`;
            const message = `
            ${messageId}
            These changes were released in [${release.name}](${release.html_url}).
            `;
            
            // Ð¡reate a new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_id,
              body: message
            });
          }

          releaseID = INPUT_RELEASE_ID;
          if (!releaseID) {
            console.log("Fetching release ID from GitHub context...");
            releaseID = context.payload.release.id;
            console.log(`Release ID: releaseID`);
          } else {
            console.log(`Using supplied 'release_id': releaseID`);
          }

          // Fetching details of the current release
          currentReleaseResponse = await github.rest.repos.getRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,            
            releaseID,
          });

          currentRelease = currentReleaseResponse.data;

          // Extracting tag name and target branch from the current release
          currentTag = currentRelease.tag_name;
          currentBranch = currentRelease.target_commitish;

          // Listing all releases of the repository
          releases = await github.rest.repos.listReleases({
            owner: context.repo.owner,
            repo: context.repo.repo,            
          });

          // Initializing variables for storing information about the previous release
          previousRelease = null;
          currentReleaseFound = false;  

          // Filter releases
          const releasesFiltered = releases.data(({release}) => release.match(${{ inputs.include_regex }})); 

          // Iterating through releases to find the previous release relative to the current one
          for (release of releasesFiltered) {
            if (currentReleaseFound) {
              previousRelease = release;
              break;
            } else if (release.tag_name == currentTag) {
              currentReleaseFound = true;
            }
          }

          // If no previous release is found, log a message and return
          if (previousRelease == null) {
            console.log(`No previous release found for ${currentTag}`);
            return;
          }

          // Comparing commits between the current and previous releases
          commitsResponse = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,            
            base: previousRelease.tag_name,
            head: currentRelease.tag_name,
          });

          commits = commitsResponse.data;

          // Initializing an array to store pull request numbers associated with the commits
          pull_requests = [];

          // Iterating through commits to find associated pull requests and extracting their numbers
          for (commit of commits.commits) {
            responseCommit = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,            
              commit_sha: commit.sha,
            });

            // GraphQL query to fetch details about the commit, including associated pull requests
            const query = `
              {
                resource(url: "${context.payload.repository.html_url}/commit/${commit.sha}") {
                  ... on Commit {
                    messageHeadlineHTML
                    messageBodyHTML
                    associatedPullRequests(first: 10) {
                      pageInfo { hasNextPage }
                      edges { node { number } }
                    }
                  }
                }
              }
            `;

            response = await github.graphql(query);

            // Extracting pull request numbers from the GraphQL response
            for (edge of response.resource.associatedPullRequests.edges) {
              pull_requests.push(edge.node.number);
            }
          }            

          // Iterating through unique pull request numbers and creating or updating comments for them
          for (id of pull_requests.filter(onlyUnique)) {
            await createCommentForPR(id, currentRelease);
          }
